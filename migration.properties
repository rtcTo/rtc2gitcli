#
# Contains all needed information used while migrate from RTC to git
# uncomment and change the defaults as needed.
#

# User name and email address for the default git user if not defined
# by the RTC check-in information
#
#user.email=rtc2git@rtc.to
#user.name=RTC 2 git

# Optional - Set encoding of files (For example encoding = UTF-8)
# See "https://github.com/rtcTo/rtc2git/wiki/Encoding" for further instructions
#
#file.encoding=UTF-8

# Optional, defines a baseline name filter
#
# Here you define a regex for baselines that should be tagged in git.
# By default no tags are created.
#
# Example for all baselines
rtc.baseline.include=^(.*)$
#
#rtc.baseline.include=

# Ignore changesets that do not result in changes to any (non-ignored) files.
# Making a source code change that has no changes is usually a mistake and clients usually
# prevent users from doing this by accident.
# With RTC, it's possible to deliver changesets that have no changes, or (if the original
# author was "particularly inventive") which only change ignored files.
# This scenario results in an empty commit for git, and by default git will prevent empty
# commits from being added, so by default the migration tool skips these.
# You can either ignore these commits (the default) or, if this is set to "true", you
# can allow these empty commits to be added to the git history to preserve the empty change
# as-is.
#
# git.allow.empty.commits=false
git.allow.empty.commits=true

# RTC allows folks to check in empty folders, but git does not.
# This option enables functionality that will generate a dummy .gitignore file in empty
# folders so that git will be able to store the folder.
# This functionality is disabled by default in the code, but can be enabled by setting
# the property to true.
#
# preserve.empty.folders=false
preserve.empty.folders=true

# Optional, defines a work item number format to apply on each work item bound to
# the specific RTC changeset (if any)
#
# In case you have migrated your workitems to another issue system (like jira/github/bitbucket)
# by using rtc2jira, you can define a prefix for the commit-message, in order that previously
# linked rtc commits get linked to the new issue system.
#
# The syntax is that of a String.format, where
# %1$s = the RTC work item number in string form
# %2$s = the RTC title text
# %3$s = the RTC server URL
# ...and, as this is a String.format, %n = a newline etc
#
# Example for a Jira project: AP- (Project has the key AP and is followed by a dash)
# rtc.workitem.number.format=AP-%s
# Note: Unlike most properties set in this file, these values are not trimmed before use,
# thus allowing you to specify trailing spaces if you wish.
#
# For more detailed information about smart commits see:
# https://confluence.atlassian.com/jiracloud/processing-jira-issues-with-commit-messages-740098538.html
#
#rtc.workitem.number.format=%1s

# Optional, defines the delimiter between multiple formatted RTC work item numbers.
# The syntax is the same as above.
# The default is a single space if not defined.
#
#rtc.workitem.number.delimiter= 

# Optional, defines start-of-list and end-of-list delimiters that are ONLY included if there are
# one or more RTC work item numbers.
# The syntax is the same as above, except %1$s is the RTC server URL and the only parameter.
# The default is no prefix or suffix.
#rtc.workitem.number.prefix=
#rtc.workitem.number.suffix=

# The above can be combined. e.g.
#   rtc.workitem.number.prefix=[RTC-
#   rtc.workitem.number.format=%s
#   rtc.workitem.number.delimiter=,
#   rtc.workitem.number.listend=]: 
# would result in an empty string when there are no work items, the text "[RTC-123]: " if there is one work item
# number 123, and the text "[RTC-123,RTC-456]: " if there are two work items, 123 and 456.

# Optional, defines a work item text format to apply on each work item's text bound to
# the specific RTC changeset (if any)
# In case you have *not* migrated your workitems to another issue system (like jira/github/bitbucket)
# you can include the original work item title in your git commit messages.
#
# The syntax is exactly the same as for rtc.workitem.number.*
#
#rtc.workitem.text.format=%1s %2s
#rtc.workitem.text.delimiter=%n
#rtc.workitem.text.prefix=
#rtc.workitem.text.suffix=

# Optional commit message search/replace pairs being applied to to commit comment before the
# actual commit. The entries have to be in pairs of commit.message.regex.X/commit.message.replacement.X
# where X must be a unique decimal number.
#
#commit.message.regex.1=^(.*)$
#commit.message.replacement.1=$1

# Optional, defines the final commit message format.
# The syntax is a Java String.format string with the following parameters:
# %1$s = the result of the rtc.workitem.number.* replacement
# %2$s = the result of the commit.message.* result
# %3$s = the result of the rtc.workitem.text.* replacement
# %4$s = the URI of the RTC server the changes came from
# %5$s = the ID of the RTC stream the changes came from
# %6$s = the ID of the RTC changeset containing the changes.
# The result will be trimmed.
# e.g.
#   %1$s %3$s %2$s%n%4$sresource/itemOid/com.ibm.team.scm.ChangeSet/%6$s
# would include the work item numbers, their text, the changeset text, then a newline
# and the URL of the changeset (on the RTC server's WebUI).
# e.g.
#   %1$s %3$s %2$s%n%4$sweb#action=com.ibm.team.scm.viewChangeSet&contextItemId=%5$s&contextItemType=com.ibm.team.scm.Workspace&changeSetItemId=%6$s
# would include the work item numbers, their text, the changeset text, then a newline
# and the URL of the changeset (on the RTC server's WebUI) in the context of the stream it came from.
#
#commit.message.format=%1s %2s
rtc.workitem.number.prefix=[RTC-
rtc.workitem.number.format=%1$s
rtc.workitem.number.delimiter=,
rtc.workitem.number.suffix=]: 
rtc.workitem.text.prefix=%n%n
rtc.workitem.text.format=%2$s%n%3$sweb#action=com.ibm.team.workitem.viewWorkItem&id=%1$s
rtc.workitem.text.delimiter=%n%n
rtc.workitem.text.suffix=
commit.message.format=%1$s%2$s%3$s%n%n%4$sweb#action=com.ibm.team.scm.viewChangeSet&contextItemId=%5$s&contextItemType=com.ibm.team.scm.Workspace&changeSetItemId=%6$s

# Optional, defines the commit note format (added via git note).
# The syntax is the same as for commit.message.format.
# If the result is an empty string then no note is added.
# WARNING: git notes are not pushed or pulled by default.
#
#commit.note.format=

# Optional, specifies the line(s) which are added to .gitattributes
# Define a semicolon-separated list of lines
#
# Example:
# gitattributes=# handle text files; * text=auto; *.sql text
#
#gitattributes=
gitattributes=*.cmd text eol=crlf;*.bat text eol=crlf;*.sln eol=crlf;*.vcproj eol=crlf;*.vcxproj eol=crlf;*.vcxproj.filters eol=crlf;*.rc eol=crlf;*.resx eol=crlf;# Reg files are UTF-16 and can be corrupted if treated as text;*.reg binary;*.REG binary;# MSVC res files are sometimes binary;*.res binary;# VB binary file;*.pgx binary;*.exe binary;*.EXE binary;*.pdb binary;*.PDB binary;*.dll binary;*.DLL binary;*.pdf binary;*.PDF binary;*.sh text eol=lf;*.bash text eol=lf

# Ignore and exclude big (binary) files
# Define a semicolon-separated list of extensions to be ignored and excluded from the migration.
# Each entry will be trimmed of whitespace.
# If we see any files whose names end in any of these these arrive, a .gitignore file will
# be created (even if there's no .jazzignore) and set to ignore the file, and we won't include
# the file in the new git repo.
#
# Example:
# ignore.file.extensions=.zip; .jar; .exe; .dll
#
#ignore.file.extensions=

# Optional: global .gitignore entries
# Define a semicolon-separated list of additional .gitignore entries being added
# Any files listed here will be ignored in the repo's root .gitignore file and
# excluded from the migration.
#
# Example:
# global.gitignore.entries=/projectX/WebContent/node_modules; *.ignored
#
#global.gitignore.entries=

# Optional: trust jazzignore files
# Folks can do silly things like creating .jazzignore files that ignore important
# files (like the .jazzignore file itself) ... but store the "should be ignored"
# file into RTC anyway.
# If the migration blindly obeys the instructions on what to ignore then we can
# ignore files that "should've been ignored by RTC but weren't" and leave the
# resulting git repository missing crucial "ignored" files.
#
# Sometimes we want to clean the repo by only storing what we should've stored,
# so removing files that RTC should've ignored in the right thing to do.
# If that's the case, set:
#   trust.jazzignore.files=true
#
# Sometimes we want the git repo to accurately reflect the RTC history exactly
# as it was, mistakes and all.  If that's the case, set:
#   trust.jazzignore.files=false
# If we're not trusting the jazzignore files then the migration will still create
# .gitignore files from .jazzignore files as normal, but it will no longer ignore
# the .gitignored files UNLESS these files have been ignored by either the
# ignore.file.extensions or global.gitignore.entries settings.
# i.e. only obeying migration properties, not .jazzignore file contents.
#
# The code defaults to trusting .jazzignored files.
#trust.jazzignore.files=true
trust.jazzignore.files=false

# Optional: remove .gitignore files between commits
# RTC can get confused by the presence of files it didn't put in the workspace.
# This can result in changesets not being applied correctly, e.g. if a changeset
# deletes a folder and its content, but there's a .gitignore file in the folder
# as well as the RTC content then RTC can fail to delete the folder, leading to
# the filesystem being out of step.
# Only enable this if necessary as it results in a performance penalty.
#
# purge.gitignore.files.between.commits=false
purge.gitignore.files.between.commits=true

# Maximum number of streams to open at a time. Open packs count against the process limits
#
#packedgitopenfiles=128

# Maximum number bytes of heap memory to dedicate to caching pack file data
#
#packedgitlimit=10m

# Size in bytes of a single window read in from the pack file
#
#packedgitwindowsize=8k

# Enables use of Java NIO virtual memory mapping for windows; false reads entire window
# into a byte[] with standard read calls
#
#packedgitmmap=false

# maximum number of bytes to cache in delta base cache for inflated, recently accessed
# objects, without delta chains
#
#deltabasecachelimit=10m

# new byte limit for objects that must be streamed. Objects smaller than this size can be
# obtained as a contiguous byte array, while objects bigger than this size require using an
#
#streamfilethreshold=50m
