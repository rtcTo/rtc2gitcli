#!/bin/bash
#
# Creates a JAR file whose only content is a MANIFEST.MF file that includes
# the entire contents of a folder on the classpath.
# This allows us to put a huge load of things on the classpath just by
# including a single jar (generated by this script) on the classpath ...
# ... which is what we need to do if we are to get anywhere persuading
# maven that the RTC scm tools JARs will be available at runtime.
#
# $1 = name of jar to create
# $2 = folder whose contents is to go on the classpath

set -e
set -u
set -o pipefail

SCRIPTNAME=$(basename "$0")
TEMPDIRTODELETE=$(mktemp --directory)

# Deletes a folder and its contents, even if Microsoft are involved.
# If we are running in an environment where our working folder is a Microsoft
# Windows filesystem then the filesystem is fundamentally unreliable and thus
# "rm -rf" can fail for no good reason.  So we retry :-(
# (Actually the reason is "file in use" because Windows OSs have a lot of
# processes which lock files "open" - File Explorer, Windows Search and most
# anti-virus software are common culprits and "difficult to remove")
robustlyDelete() {
  for attempt in 1 2 3 4 5
  do
    if rm -rf "${@}"
    then
      return 0
    else
      sleep 1
    fi
  done
  rm -rf "${@}"
}

cleanUpOnExit() {
  if [ -n "${TEMPDIRTODELETE}" ]
  then
    robustlyDelete "${TEMPDIRTODELETE}"
    TEMPDIRTODELETE=''
  fi
}

trap cleanUpOnExit EXIT ERR

# Manifest files only permit short lines.
# Lines longer than 70 chars need to be wrapped and prefixed by a space on subsequent lines.
# stdin = one long line in need of wrapping
# stdout = one or more lines that are 70 characters or less.
wrapTextForManifest() {
  # Make sure we preserve spaces when reading/writing
  local IFS=
  # Read up to 70 characters
  local firstline
  if read -r -N 70 firstline
  then
    # output as-is
    echo "${firstline}"
  fi
  # subsequent characters need to be put on following lines
  # and each indented with one space.
  local nextline
  while read -r -N 69 nextline
  do
    echo " ${nextline}"
  done
}

# stdin = files, one per line
# stdout = classpath, with no EOL
filesToSpaceSeparatedList() {
  sort | tr '\r\n' '  ' | sed -e 's/  */ /g' -e 's/^ //g' -e 's/ $//g'
}

# stdin = multi-line list of what to put on the classpath
# $1 = where to create the jar file
# $TEMPDIRTODELETE = temp area we can use
createJarWithClasspathManifest() {
  local jarname="$1"
  shift
  local tmpdir="${TEMPDIRTODELETE}"
  # make a readme file
  (
    echo 'This JAR simply lists other jar files in its Class-Path'
  ) > "${tmpdir}/README.txt"
  # now make the manifest file
  local metaInfFolder="${tmpdir}/META-INF"
  mkdir -p "${tmpdir}/META-INF"
  local manifestFile="${metaInfFolder}/MANIFEST.MF"
  (
    echo "Class-Path: $(filesToSpaceSeparatedList)" | wrapTextForManifest
    echo
  ) > "${manifestFile}"
  # and create the jar file including the readme and the manifest only.
  jar -cfm "${jarname}" "${manifestFile}" -C "${tmpdir}" "README.txt"
}

# Finds everything we might possibly need on the classpath within the
# specified folder.
# Finds all JAR files and all folders that look like the contents of JAR files.
# Note: Output is unsorted.
# $1 = folder to start searching in
dirToClasspathEntries() {
  local folder
  find "$1" -type d -print | \
  while read folder
  do
    if [ -d "${folder}/META-INF" ]
    then
      echo "${folder}/"
    fi
  done
  find "$1" -type f -name '*.jar'
}

mainMethod() {
  local jarFileName="$1"
  shift
  local jarDir=$(dirname "${jarFileName}")
  mkdir -p "${jarDir}"
  (
    cd "${jarDir}"
    for folder
    do
      dirToClasspathEntries "${folder}"
    done
  ) | createJarWithClasspathManifest "${jarFileName}"
}

mainMethod "$@"
